\chapter{YAML Configuration Loader Implementation}
\label{appendix:yaml-loader}

I developed a YAML configuration parser that transforms high-level configuration into simulation parameters. This implementation enables users to define complex experiment configurations without modifying Java code:

\begin{verbatim}
private static List<SimulationConfig> loadConfigurationsFromYaml() {
    List<SimulationConfig> configs = new ArrayList<>();

    try (InputStream inputStream = new FileInputStream(CONFIG_FILE)) {
        Yaml yaml = new Yaml();
        List<Map<String, Object>> yamlConfigs = yaml.load(inputStream);

        for (Map<String, Object> configMap : yamlConfigs) {
            int numberOfEdge = ((Number) configMap.get("numberOfEdge")).intValue();
            
            // Parse placement logic (supports both string and numeric values)
            int placementLogic;
            Object placementLogicObj = configMap.get("placementLogic");
            if (placementLogicObj instanceof String) {
                placementLogic = PlacementLogicFactory.getPlacementLogicCode((String) placementLogicObj);
                if (placementLogic == -1) {
                    System.err.println("Unknown placement logic name: " + placementLogicObj + ", skipping configuration");
                    continue;
                }
            } else {
                placementLogic = ((Number) configMap.get("placementLogic")).intValue();
            }

            // Parse user types map
            Map<String, Integer> usersPerType = new HashMap<>();
            Map<String, Object> userTypeMap = (Map<String, Object>) configMap.get("usersPerType");
            for (Map.Entry<String, Object> entry : userTypeMap.entrySet()) {
                usersPerType.put(entry.getKey(), ((Number) entry.getValue()).intValue());
            }
            
            // Parse interval values for Poisson distribution
            Map<String, Integer> intervalValues = new HashMap<>();
            if (configMap.containsKey("intervalValues")) {
                Map<String, Object> intervalMap = (Map<String, Object>) configMap.get("intervalValues");
                for (Map.Entry<String, Object> entry : intervalMap.entrySet()) {
                    intervalValues.put(entry.getKey(), ((Number) entry.getValue()).intValue());
                }
            }

            // Read random seed values if present
            int experimentSeed = 33; // Default value
            int locationSeed = 42; // Default value
            int mobilityStrategySeed = 123; // Default value
            int heuristicSeed = 456; // Default value for heuristic placement algorithms
            
            if (configMap.containsKey("randomSeeds")) {
                Map<String, Object> randomSeedsMap = (Map<String, Object>) configMap.get("randomSeeds");
                if (randomSeedsMap.containsKey("experimentSeed")) {
                    experimentSeed = ((Number) randomSeedsMap.get("experimentSeed")).intValue();
                }
                if (randomSeedsMap.containsKey("locationSeed")) {
                    locationSeed = ((Number) randomSeedsMap.get("locationSeed")).intValue();
                }
                if (randomSeedsMap.containsKey("mobilityStrategySeed")) {
                    mobilityStrategySeed = ((Number) randomSeedsMap.get("mobilityStrategySeed")).intValue();
                }
                if (randomSeedsMap.containsKey("heuristicSeed")) {
                    heuristicSeed = ((Number) randomSeedsMap.get("heuristicSeed")).intValue();
                }
            }
            
            // Read placement process interval if present
            double placementProcessInterval = 60.0; // Default value matches MicroservicePlacementConfig
            if (configMap.containsKey("placementProcessInterval")) {
                placementProcessInterval = ((Number) configMap.get("placementProcessInterval")).doubleValue();
            }

            // Check for new format (numberOfApplications and appLoopLength)
            if (configMap.containsKey("numberOfApplications") && configMap.containsKey("appLoopLength")) {
                int numberOfApplications = ((Number) configMap.get("numberOfApplications")).intValue();
                int appLoopLength = ((Number) configMap.get("appLoopLength")).intValue();
                
                configs.add(new SimulationConfig(
                    numberOfEdge, 
                    placementLogic, 
                    numberOfApplications,
                    appLoopLength,
                    usersPerType,
                    intervalValues,
                    experimentSeed,
                    locationSeed,
                    mobilityStrategySeed,
                    heuristicSeed,
                    placementProcessInterval
                ));
            } 
            // Legacy format with appLoopLengthPerType
            else if (configMap.containsKey("appLoopLengthPerType")) {
                // Parse app loop lengths map (legacy format)
                Map<String, Integer> appLoopLengthPerType = new HashMap<>();
                Map<String, Object> loopLengthMap = (Map<String, Object>) configMap.get("appLoopLengthPerType");
                for (Map.Entry<String, Object> entry : loopLengthMap.entrySet()) {
                    appLoopLengthPerType.put(entry.getKey(), ((Number) entry.getValue()).intValue());
                }
                
                configs.add(new SimulationConfig(
                    numberOfEdge, 
                    placementLogic, 
                    usersPerType, 
                    appLoopLengthPerType,
                    experimentSeed,
                    locationSeed,
                    mobilityStrategySeed
                ));
            }
            else {
                System.err.println("Configuration missing required fields, skipping");
            }
        }

        System.out.println("Loaded " + configs.size() + " configurations from " + CONFIG_FILE);
    } catch (IOException e) {
        System.err.println("Error loading configurations from " + CONFIG_FILE);
        e.printStackTrace();
    }

    return configs;
}
\end{verbatim}

This configuration loader supports both string-based and numeric identifiers for placement logic, making it more user-friendly. It also handles different configuration formats with backward compatibility and provides sensible defaults when optional parameters are omitted. 