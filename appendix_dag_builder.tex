\chapter{Application DAG Builder Implementation}
\label{appendix:dag-builder}

I implemented a flexible DAG generator for applications with variable service chain lengths. This implementation creates linear pipelines of configurable length with randomized resource requirements:

\begin{verbatim}
private static MyApplication createApplication(String appId, int brokerId, int numServices, int randomSeed) {
    MyApplication application = MyApplication.createMyApplication(appId, brokerId);
    Random random = new Random(randomSeed);

    // Prefix all module names with the app ID FOR UNIQUENESS OF MODULE NAMES
    String clientModuleName = appId + "_clientModule";
    application.addAppModule(clientModuleName, 4, 4, 50);

    for (int i = 1; i <= numServices; i++) {
        String serviceName = appId + "_Service" + i;
        application.addAppModule(serviceName, 
            random.nextInt(501) + 250,  // CPU requirement between 250-750 MIPS
            random.nextInt(501) + 250,  // RAM requirement between 250-750 MB
            500);                       // Storage requirement fixed at 500 MB
    }

    /*
     * Connecting the application modules (vertices) in the application model (directed graph) with edges
     */
    application.addAppEdge("SENSOR", clientModuleName, 14, 50, "SENSOR", Tuple.UP, AppEdge.SENSOR);

    String firstServiceName = appId + "_Service1";
    application.addAppEdge(clientModuleName, firstServiceName, 3000, 300,
            appId + "_RAW_DATA", Tuple.UP, AppEdge.MODULE);
    for (int i = 1; i < numServices; i++) {
        String sourceModule = appId + "_Service" + i;
        String destModule = appId + "_Service" + (i+1);
        String tupleType = appId + "_FILTERED_DATA" + i;

        application.addAppEdge(sourceModule, destModule, 3000, 300, tupleType, Tuple.UP, AppEdge.MODULE);
    }

    String lastServiceName = appId + "_Service" + numServices;
    application.addAppEdge(lastServiceName, clientModuleName, 4, 500,
            appId + "_RESULT", Tuple.DOWN, AppEdge.MODULE);

    // Connect to actuator
    application.addAppEdge(clientModuleName, "DISPLAY", 4, 50,
            appId + "_RESULT_DISPLAY", Tuple.DOWN, AppEdge.ACTUATOR);

    /*
     * Defining the input-output relationships (represented by selectivity) of the application modules.
     */
    application.addTupleMapping(clientModuleName, "SENSOR", appId + "_RAW_DATA",
            new FractionalSelectivity(1.0));

    for (int i = 1; i < numServices; i++) {
        String sourceModule = appId + "_Service" + i;
        String inputTupleType = (i == 1) ? appId + "_RAW_DATA" : appId + "_FILTERED_DATA" + (i-1);
        String outputTupleType = appId + "_FILTERED_DATA" + i;

        application.addTupleMapping(sourceModule, inputTupleType, outputTupleType,
                new FractionalSelectivity(1.0));
    }

    String lastInputTupleType = (numServices == 1) ? appId + "_RAW_DATA" : appId + "_FILTERED_DATA" + (numServices-1);
    application.addTupleMapping(appId + "_Service" + numServices, lastInputTupleType,
            appId + "_RESULT", new FractionalSelectivity(1.0));

    application.addTupleMapping(clientModuleName, appId + "_RESULT",
            appId + "_RESULT_DISPLAY", new FractionalSelectivity(1.0));

    final AppLoop loop = new AppLoop(new ArrayList<String>() {{
        add("SENSOR");
        add(clientModuleName);

        for (int i = 1; i <= numServices; i++) {
            add(appId + "_Service" + i);
        }

        add(clientModuleName);
        add("DISPLAY");
    }});

    List<AppLoop> loops = new ArrayList<AppLoop>() {{
        add(loop);
    }};
    application.setLoops(loops);

    return application;
}
\end{verbatim}

This DAG builder dynamically creates a unique service pipeline for each application, with configurable length (numServices) and randomized resource requirements. The implementation ensures that all module names and tuple types are unique by prefixing them with the application ID. This allows multiple applications to coexist in the simulation without naming conflicts. 